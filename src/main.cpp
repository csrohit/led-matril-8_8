 #include <Arduino.h>


#define latchPin 3
#define clockPin 4
#define dataPin 2 

char msg[] ="Z[\\]^`+-*/AaBbZz ";//Change the text here.
int scrollspeed=5;//Set the scroll speed ( lower=faster)

int x;
int y;

//Columns

//BITMAP
//Bits in this array represents one LED of the matrix
// 8 is # of rows, 6 is # of LED matrices
byte bitmap[8][7]; 

int numZones = sizeof(bitmap) / 8; // One Zone refers to one 8 x 8 Matrix ( Group of 8 columns)
int maxZoneIndex = numZones-1;
int numCols = numZones * 8;





//FONT DEFENITION
byte alphabets[][8] = {
  
  {0x00,0x00,0x00,0x00,0x00}, // 32 => space
  {0x00,0x00,0x7d,0x00,0x00}, // 33 => !
  {0x00,0x70,0x00,0x70,0x00}, // 34 => "
  {0x14,0x7f,0x14,0x7f,0x14}, // 35 => #
  {0x12,0x2a,0x7f,0x2a,0x24}, // 36 => $
  {0x63,0x64,0x08,0x13,0x63}, // 37 => %
  {0x36,0x49,0x55,0x22,0x05}, // 38 => &
  {0x00,0x00,0x60,0x00,0x00}, // 39 => '
  {0x00,0x08,0x36,0x41,0x00}, // 40 => (
  {0x00,0x41,0x36,0x08,0x00}, // 41 => )
  {0x14,0x08,0x3e,0x08,0x14}, // 42 => *
  {0x08,0x08,0x3e,0x08,0x08}, // 43 => +
  {0x00,0x20,0x10,0x08,0x00}, // 44 => `
  {0x08,0x08,0x08,0x08,0x08}, // 45 => -
  {0x00,0x03,0x03,0x00,0x00}, // 46 => .
  {0x03,0x04,0x08,0x10,0x60}, // 47 => /
  {0x3e,0x61,0x5d,0x43,0x3e}, // 48 => 0
  {0x00,0x21,0x7f,0x01,0x00}, // 49 => 1 
  {0x23,0x45,0x49,0x49,0x31}, // 50 => 2
  {0x22,0x49,0x49,0x49,0x36}, // 51 => 3
  {0x0c,0x14,0x24,0x7f,0x04}, // 52 => 4
  {0x72,0x51,0x51,0x51,0x4e}, // 53 => 5
  {0x1e,0x29,0x49,0x49,0x06}, // 54 => 6
  {0x43,0x44,0x48,0x50,0x60}, // 55 => 7
  {0x36,0x49,0x49,0x49,0x36}, // 56 => 8
  {0x30,0x49,0x49,0x4a,0x3c}, // 57 => 9
  {0x00,0x36,0x36,0x00,0x00}, // 58 => :
  {0x00,0x36,0x35,0x00,0x00}, // 59 => ;
  {0x08,0x14,0x22,0x41,0x00}, // 60 => <
  {0x14,0x14,0x14,0x14,0x14}, // 61 => =
  {0x41,0x22,0x14,0x08,0x00}, // 62 => >
  {0x20,0x40,0x45,0x48,0x30}, // 63 => ?
  {0x26,0x49,0x4f,0x41,0x3e}, // 64 => @
  {0x1f,0x24,0x44,0x24,0x1f}, // 65 => A
  {0x7f,0x49,0x49,0x49,0x36}, // 66 => B
  {0x3e,0x41,0x41,0x41,0x22}, // 67 => C
  {0x7f,0x41,0x41,0x22,0x1c}, // 68 => D
  {0x7f,0x49,0x49,0x41,0x41}, // 69 => E
  {0x7f,0x48,0x48,0x48,0x40}, // 70 => F
  {0x3e,0x41,0x41,0x45,0x26}, // 71 => G
  {0x7f,0x08,0x08,0x08,0x7f}, // 72 => H
  {0x00,0x41,0x7f,0x41,0x00}, // 73 => I
  {0x20,0x01,0x01,0x01,0x7e}, // 74 => J
  {0x7f,0x08,0x14,0x22,0x41}, // 75 => K
  {0x7f,0x01,0x01,0x01,0x01}, // 76 => L
  {0x7f,0x20,0x10,0x20,0x7f}, // 77 => M
  {0x7f,0x20,0x10,0x08,0x7f}, // 78 => N
  {0x3e,0x41,0x41,0x41,0x3e}, // 79 => O
  {0x7f,0x48,0x48,0x48,0x30}, // 80 => P
  {0x3e,0x41,0x45,0x42,0x3d}, // 81 => Q
  {0x7f,0x48,0x4c,0x4a,0x31}, // 82 => R
  {0x32,0x49,0x49,0x49,0x26}, // 83 => S
  {0x40,0x40,0x7f,0x40,0x40}, // 84 => T
  {0x7e,0x01,0x01,0x01,0x7e}, // 85 => U
  {0x7c,0x02,0x01,0x02,0x7c}, // 86 => V
  {0x7e,0x01,0x06,0x01,0x7e}, // 87 => W
  {0x63,0x14,0x08,0x14,0x63}, // 88 => X
  {0x60,0x10,0x0f,0x10,0x60}, // 89 => Y
  {0x43,0x45,0x49,0x51,0x61}, // 90 => Z 
  {0x00,0x7f,0x41,0x41,0x00}, // 91 => [
  {0x60,0x10,0x08,0x04,0x03}, // 92 => \ 
  {0x00,0x7f,0x41,0x41,0x00}, // 93 => ^
  {0x00,0x41,0x41,0x7f,0x00}, // 94 => ] 
  {0x10,0x20,0x40,0x20,0x10}, // 95 => ^ 
  {0x00,0x40,0x20,0x10,0x00}, // 96 => ` 
  {0x00,0x40,0x20,0x10,0x00}, // 96 => ` 
  {0x02,0x15,0x15,0x15,0x0f}, // 97 => a
  {0x7f,0x09,0x11,0x11,0x0e}, // 98 => b 
  {0x0e,0x11,0x11,0x11,0x02}, // 99 => c 
  {0x0e,0x11,0x11,0x09,0x7f}, // 100 => d 
  {0x0e,0x15,0x15,0x15,0x0c}, // 101 => e
  {0x08,0x3f,0x48,0x40,0x20}, // 102 => f
  {0x08,0x15,0x15,0x15,0x1e}, // 103 => g
  {0x7f,0x08,0x10,0x10,0x0f}, // 104 => h 
  {0x00,0x11,0x5f,0x01,0x00}, // 105 => i
  {0x02,0x01,0x09,0x5e,0x00}, // 106 => j
  {0x7f,0x04,0x0a,0x11,0x00}, // 107 => k
  {0x00,0x41,0x7f,0x01,0x00}, // 108 => l
  {0x1f,0x10,0x0f,0x10,0x0f}, // 109 => m
  {0x1f,0x08,0x10,0x10,0x0f}, // 110 => n
  {0x0e,0x11,0x11,0x11,0x0e}, // 111 => o
  {0x1f,0x14,0x14,0x08,0x00}, // 112 => p
  {0x08,0x14,0x14,0x0c,0x1f}, // 113 => q
  {0x1f,0x08,0x10,0x10,0x08}, // 114 => r
  {0x09,0x15,0x15,0x15,0x02}, // 115 => s
  {0x10,0x7e,0x11,0x01,0x02}, // 116 => t
  {0x1f,0x02,0x01,0x01,0x1e}, // 117 => u
  {0x1c,0x02,0x01,0x02,0x1c}, // 118 => v
  {0x1e,0x01,0x1e,0x01,0x1e}, // 119 => w
  {0x11,0x0a,0x04,0x0a,0x11}, // 120 => x
  {0x18,0x05,0x05,0x05,0x1e}, // 121 => y
  {0x11,0x13,0x15,0x19,0x11}, // 122 => z
};

void setup() {
 pinMode(latchPin, OUTPUT);
 pinMode(clockPin, OUTPUT);
 pinMode(dataPin, OUTPUT);
 //Clear bitmap
 for (int row = 0; row < 8; row++) {
   for (int zone = 0; zone <= maxZoneIndex; zone++) {
     bitmap[row][zone] = 0; 
   }
 }
}

//FUNCTIONS
// Displays bitmap array in the matrix
void RefreshDisplay()
{




 for (uint8_t row = 0; row < 8; row++) {
   int rowbit = 1 << row;
   digitalWrite(latchPin, LOW);//Hold latchPin LOW for transmitting data

   //Shift out to each matrix
   for (int zone = maxZoneIndex; zone >= 0; zone--) 
   {
     shiftOut(dataPin, clockPin, MSBFIRST, ~bitmap[row][zone]);
   }

   shiftOut(dataPin, clockPin, MSBFIRST, rowbit);   //Transmit data

   //flip both latches at once to eliminate flicker
   digitalWrite(latchPin, HIGH);//Return the latch pin 1 high to signal chip

   //Wait
   delayMicroseconds(300);
 }
}

// Converts row and colum to bitmap bit and turn it off/on
void Plot(int col, int row, bool isOn)
{
 int zone = col / 8;
 int colBitIndex = x % 8;
 byte colBit = 1 << colBitIndex;
 if (isOn)
   bitmap[row][zone] =  bitmap[y][zone] | colBit;
 else
   bitmap[row][zone] =  bitmap[y][zone] & (~colBit);
}
// Plot each character of the message one column at a time, updated the display, shift bitmap left.
void XProcess()
{
 for (int charIndex=0; charIndex < (sizeof(msg)-1); charIndex++)
 {
   int alphabetIndex = msg[charIndex] - 32;
   if (alphabetIndex < 0) alphabetIndex=0;
   
   //Draw one character of the message
   // Each character is 5 columns wide, loop two more times to create 2 pixel space betwen characters
   for (int col = 0; col < 7; col++)
   {
     for (int row = 0; row < 8; row++)
     {
       // Set the pixel to what the alphabet say for columns 0 thru 4, but always leave columns 5 and 6 blank.
       bool isOn = 0; 
       if (col<5) isOn = bitRead( alphabets[alphabetIndex][col], 7-row ) == 1;
       Plot( numCols-1, row, isOn); //Draw on the rightmost column, the shift loop below will scroll it leftward.
     }
     for (int refreshCount=0; refreshCount < scrollspeed; refreshCount++)
       RefreshDisplay();
     //Shift the bitmap one column to left
     for (int row=0; row<8; row++)
     {
       for (int zone=0; zone < numZones; zone++)
       {
         //This right shift would show as a left scroll on display because leftmost column is represented by least significant bit of the byte.
         bitmap[row][zone] = bitmap[row][zone] >> 1;
         // Shift over lowest bit from the next zone as highest bit of this zone.
         if (zone < maxZoneIndex) bitWrite(bitmap[row][zone], 7, bitRead(bitmap[row][zone+1],0));
       }
     }
   }
 }
}
void loop() {
 XProcess();
}